# This script must contain one folder for the module to be implemented
# This folder must be named PR_WRP
# The contents of this folder must be copied from this one, generated by Vivado HLS:
# .../solution/impl/vhdl

# *********USE THE OPTION config_interface -m_axi_addr64 TO RUN VIVADO HLS**********

# This file must be executed with the following command:
# vivado -mode TCL -source Gen_Module.tcl 

# ---------------------------   Generate OOC for Kernel  --------------------------------------------

# Define the FPGA
set device xczu9eg
set package -ffvc900
set speed -1-i-es1

# Module Namme inside the wrapper
set ModName PR_WRP


cd ./$ModName


# folder used to implement the kernel
file mkdir ./OOC
exec mv ../Sources/PR_WRP.vhd ./OOC/PR_WRP.vhd


# implements the kernel generated by Vivado HLS
set part_sh [open "part.sh" "w"]
set ::env(part_nmbr) ${device}${package}${speed} 
puts $part_sh  {cat run_vivado.tcl | sed 's/set targetPart ${device}${package}${speed}/set targetPart $env(part_nmbr) /g' > ./run_vivado_new.tcl}
#puts $part_sh  {cat run_vivado.tcl >./run_vivado_new.tcl}
close $part_sh
exec chmod u+x ./part.sh
exec ./part.sh

set targetPart ${device}${package}${speed}
source ./run_vivado_new.tcl


cd ./OOC

# ---------------------------------------------------------------------------------------------
# Insert the synthesized kernel into wrapper file
# substitute lines with '";' by '" ;' The former causes an error when reading lists
set ::env(wrp_file_name) PR_WRP 
set ::env(top_file_name) $top_module
set ::env(new_append) _new
set sub_sh [open "sub.sh" "w"]
puts $sub_sh  {cat PR_WRP.vhd | sed 's/";/"  ;/g' >PR_WRP_new.vhd}
puts $sub_sh  {cat ../${top_file_name}.vhd | sed 's/";/"  ;/g' >${top_file_name}${new_append}.vhd}
close $sub_sh
exec chmod u+x ./sub.sh
exec ./sub.sh

# read wrapper file 
set WRP_File [open "$env(wrp_file_name)_new.vhd" r]
set WRP_File_buf [read -nonewline $WRP_File]
close $WRP_File
set WRP_File_buf_s [split $WRP_File_buf "\n"]

# reads top VHDL from HLS tool
set TOP_File [open "$env(top_file_name)_new.vhd" r]
set TOP_File_buf [read -nonewline $TOP_File]
close $TOP_File
set TOP_File_buf_s [split $TOP_File_buf "\n"]

# Create new wrapper file with the required component
set WRP_NEW_File [open "PR_WRP_NEW.vhd" "w"]				

# Update the module name
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "entity PR_WRP is"] [lsearch -regexp $WRP_File_buf_s "entity PR_WRP is"] "entity $ModName is"]
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "end PR_WRP;"] [lsearch -regexp $WRP_File_buf_s "end PR_WRP;"] "end $ModName;"]
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "architecture Behavioral of PR_WRP is"] [lsearch -regexp $WRP_File_buf_s "architecture Behavioral of PR_WRP is"] "architecture Behavioral of $ModName is"]



# copy template wrapper up to the component declaration place
set top_wrapper [lsearch -regexp $WRP_File_buf_s "--comp"]
for {set j 0} {$j<$top_wrapper} {incr j} 	{
puts $WRP_NEW_File [lindex $WRP_File_buf_s $j]
											}
				

				
												
puts $WRP_NEW_File "component $env(top_file_name) is"

# copy component ports from VHDL generated by HLS tool
set start_cmp [lsearch -regexp $TOP_File_buf_s "generic"]
set end_cmp [lsearch -regexp $TOP_File_buf_s  "end;"]
for {set j $start_cmp} {$j<$end_cmp} {incr j} 	{
puts $WRP_NEW_File [lindex $TOP_File_buf_s $j]
												}
puts $WRP_NEW_File "end component;"

# generate componente instantiation
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "PR_Kernel"] [lsearch -regexp $WRP_File_buf_s "PR_Kernel"] "PR_Kernel: $env(top_file_name) "]

# generate the address control bits accordingto the kernel 
if [regexp  "(:=.)\([0-9]{1,3})" [lindex $TOP_File_buf_s [lsearch -regexp $TOP_File_buf_s "C_S_AXI_CONTROL_ADDR_WIDTH"]] match5 equ number] { }
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "s_axi_control_AWADDR"] [lsearch -regexp $WRP_File_buf_s "s_axi_control_AWADDR"] "s_axi_control_AWADDR 	   =>	wrp_in ([expr {24+$number}] downto 25),"]
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "s_axi_control_ARADDR"] [lsearch -regexp $WRP_File_buf_s "s_axi_control_ARADDR"] "s_axi_control_ARADDR 	   =>	wrp_in ([expr {3+$number}] downto 4),"]


# copy the bottom of the wrapper file
set size_wrapper [llength $WRP_File_buf_s]
for {set j $top_wrapper} {$j<$size_wrapper} {incr j} 	{
puts $WRP_NEW_File [lindex $WRP_File_buf_s $j]
												}		
											
close $WRP_NEW_File
# ---------------------------------------------------------------------------------------------


# create project 
create_project $projectName . -part $targetPart -force
set_property target_language $language [current_project]

add_files -norecurse ./PR_WRP_NEW.vhd 

# properties setting
if { $add_io_buffers == "false" } {
    set_property -name {STEPS.SYNTH_DESIGN.ARGS.MORE OPTIONS} -value {-no_iobuf -mode out_of_context} -objects [get_runs synth_1]
}

# XPM library support
set_param project.defaultXPMLibraries {XPM_MEMORY}

# launch run synth
launch_runs synth_1
wait_on_run synth_1
open_run synth_1

# write a few files and reports after synthesis
report_utilization -file ./${outputBaseName}_utilization_synth.rpt
report_timing -file ./${outputBaseName}_timing_synth.rpt

# insert the kernel design 
read_checkpoint -cell PR_Kernel ../project.runs/synth_1/$outputBaseName.dcp

# generate wrapper with the kernel design
write_checkpoint -force ${outputBaseName}_OOC_Kernel_Synth


#  ---------------------------------------------------------------------------------------------------

cd ../..

open_checkpoint blocker.dcp
read_checkpoint -cell inst_PR_WRP_0 ./PR_WRP/OOC/${outputBaseName}_OOC_Kernel_Synth.dcp
add_cells_to_pblock pblock_PR_Kernel_int [get_cells [list inst_PR_WRP_0]]

opt_design
place_design
route_design

# fix GND after routing
set gnd_nets [get_nets -hierarchical -filter {TYPE=="GROUND"}]
set_property is_route_fixed 1 [get_nets [lindex $gnd_nets 0]]

write_checkpoint  -force route_module_w_blocker.dcp

# unfix the blocker
set_property is_route_fixed 0 [get_nets <const1>]
#set_property is_route_fixed 0 [get_nets <const0>]

# remove the blocker
route_design    -unroute -physical_nets
route_design  -physical_nets


write_checkpoint  -force route_final.dcp

set_property BITSTREAM.GENERAL.CRC DISABLE [current_design]
set_property BITSTREAM.General.UnconstrainedPins {Allow} [current_design]


write_bitstream -bin_file ./${outputBaseName}
exit