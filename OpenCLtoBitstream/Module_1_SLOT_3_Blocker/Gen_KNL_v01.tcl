# This script must contain one folder for the module to be implemented
# This folder must be named PR_WRP
# The contents of this folder must be copied from this one, generated by Vivado HLS:
# .../solution/impl/vhdl

# *********USE THE OPTION config_interface -m_axi_addr64 TO RUN VIVADO HLS**********

# This file must be executed with the following command:
# vivado -mode TCL -source Gen_KNL_vxx.tcl 

# Parameters for Bounding Box
# Start position for PR Module (Resource Index)
set ::env(start) 0 
# Stop position for PR Module (Resource Index)
set ::env(stop)  90
# Height of PR Module (Clock Region Units)
set ::env(PRheight) 1
# Starting Row of PR Module
set ::env(CRrow) 360
# CR Height
set ::env(CRheight) 60
# DSP rows in a CR
set ::env(DSPheight) 5

# Parameters for Blocker
# HLONG wires connect 2 switch boxes 6 columns away
# HQUAD wires connect 2 switch boxes 3 columns away
# DOUBLE wires connect 2 switch boxes 1 column away
set ::env(BlockWidth)  6;
 
# SINGLE wires connect 2 switch boxes 1 row away
# DOUBLE wires connect 2 switch boxes 2 rows away
# VQUAD wires connect 2 switch boxes 4 rows away
# VLONG wires connect 2 switch boxes 12 rows away
set ::env(BlockHeight)  12; 



# ---------------------------   Generate OOC for Kernel  --------------------------------------------

# Define the FPGA
set device xczu9eg
set package -ffvc900
set speed -1-i-es1

# Folder used to store the synthesized design
file mkdir ./TOP_SYNTH


# Synthesize TOP with a black box for the module
create_project -in_memory -part ${device}${package}${speed}
set_property IP_REPO_PATHS { ../../../../../../output/export/rtf/ip/xilinx/} [current_fileset]
update_ip_catalog
add_files ./Sources/PR_TOP.vhd
add_files ./Sources/wrapper_v5.vhd


synth_design -mode default -flatten_hierarchy rebuilt -top MOD_TOP  -part ${device}${package}${speed}
write_checkpoint -force ./TOP_SYNTH/MOD_TOP.dcp
report_utilization -file ./TOP_SYNTH/MOD_TOP_utilization_synth.rpt

close_project

# Module Namme inside the wrapper
set ModName PR_WRP


cd ./$ModName


# folder used to implement the kernel
file mkdir ./OOC
exec mv ../Sources/PR_WRP.vhd ./OOC/PR_WRP.vhd


# implements the kernel generated by Vivado HLS
set part_bat [open "part.bat" "w"]
set ::env(part_nmbr) ${device}${package}${speed} 
puts $part_bat  {cat run_vivado.tcl | sed 's/set targetPart ${device}${package}${speed}/set targetPart %part_nmbr% /g' >%run_vivado_new.tcl}
close $part_bat
exec ./part.bat

set targetPart ${device}${package}${speed}
source ./run_vivado_new.tcl


cd ./OOC

# ---------------------------------------------------------------------------------------------
# Insert the synthesized kernel into wrapper file
# substitute lines with '";' by '" ;' The former causes an error when reading lists
set ::env(wrp_file_name) PR_WRP 
set ::env(top_file_name) $top_module
set sub_bat [open "sub.bat" "w"]
puts $sub_bat  {cat %wrp_file_name%.vhd | sed 's/";/"  ;/g' >%wrp_file_name%_new.vhd}
puts $sub_bat  {cat ../%top_file_name%.vhd | sed 's/";/"  ;/g' >%top_file_name%_new.vhd}
close $sub_bat
exec ./sub.bat

# read wrapper file 
set WRP_File [open "$env(wrp_file_name)_new.vhd" r]
set WRP_File_buf [read -nonewline $WRP_File]
close $WRP_File
set WRP_File_buf_s [split $WRP_File_buf "\n"]

# reads top VHDL from HLS tool
set TOP_File [open "$env(top_file_name)_new.vhd" r]
set TOP_File_buf [read -nonewline $TOP_File]
close $TOP_File
set TOP_File_buf_s [split $TOP_File_buf "\n"]

# Create new wrapper file with the required component
set WRP_NEW_File [open "PR_WRP_NEW.vhd" "w"]				

# Update the module name
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "entity PR_WRP is"] [lsearch -regexp $WRP_File_buf_s "entity PR_WRP is"] "entity $ModName is"]
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "end PR_WRP;"] [lsearch -regexp $WRP_File_buf_s "end PR_WRP;"] "end $ModName;"]
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "architecture Behavioral of PR_WRP is"] [lsearch -regexp $WRP_File_buf_s "architecture Behavioral of PR_WRP is"] "architecture Behavioral of $ModName is"]



# copy template wrapper up to the component declaration place
set top_wrapper [lsearch -regexp $WRP_File_buf_s "--comp"]
for {set j 0} {$j<$top_wrapper} {incr j} 	{
puts $WRP_NEW_File [lindex $WRP_File_buf_s $j]
											}
				

				
												
puts $WRP_NEW_File "component $env(top_file_name) is"

# copy component ports from VHDL generated by HLS tool
set start_cmp [lsearch -regexp $TOP_File_buf_s "generic"]
set end_cmp [lsearch -regexp $TOP_File_buf_s  "end;"]
for {set j $start_cmp} {$j<$end_cmp} {incr j} 	{
puts $WRP_NEW_File [lindex $TOP_File_buf_s $j]
												}
puts $WRP_NEW_File "end component;"

# generate componente instantiation
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "PR_Kernel"] [lsearch -regexp $WRP_File_buf_s "PR_Kernel"] "PR_Kernel: $env(top_file_name) "]

# generate the address control bits accordingto the kernel 
if [regexp  "(:=.)\([0-9]{1,3})" [lindex $TOP_File_buf_s [lsearch -regexp $TOP_File_buf_s "C_S_AXI_CONTROL_ADDR_WIDTH"]] match5 equ number] { }
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "s_axi_control_AWADDR"] [lsearch -regexp $WRP_File_buf_s "s_axi_control_AWADDR"] "s_axi_control_AWADDR 	   =>	wrp_in ([expr {24+$number}] downto 25),"]
set WRP_File_buf_s [lreplace $WRP_File_buf_s [lsearch -regexp $WRP_File_buf_s "s_axi_control_ARADDR"] [lsearch -regexp $WRP_File_buf_s "s_axi_control_ARADDR"] "s_axi_control_ARADDR 	   =>	wrp_in ([expr {3+$number}] downto 4),"]


# copy the bottom of the wrapper file
set size_wrapper [llength $WRP_File_buf_s]
for {set j $top_wrapper} {$j<$size_wrapper} {incr j} 	{
puts $WRP_NEW_File [lindex $WRP_File_buf_s $j]
												}		
											
close $WRP_NEW_File
# ---------------------------------------------------------------------------------------------


# create project 
create_project $projectName . -part $targetPart -force
set_property target_language $language [current_project]

add_files -norecurse ./PR_WRP_NEW.vhd 

# properties setting
if { $add_io_buffers == "false" } {
    set_property -name {STEPS.SYNTH_DESIGN.ARGS.MORE OPTIONS} -value {-no_iobuf -mode out_of_context} -objects [get_runs synth_1]
}

# XPM library support
set_param project.defaultXPMLibraries {XPM_MEMORY}

# launch run synth
launch_runs synth_1
wait_on_run synth_1
open_run synth_1

# write a few files and reports after synthesis
report_utilization -file ./${outputBaseName}_utilization_synth.rpt
report_timing -file ./${outputBaseName}_timing_synth.rpt

# insert the kernel design 
read_checkpoint -cell PR_Kernel ../project.runs/synth_1/$outputBaseName.dcp

# generate wrapper with the kernel design
write_checkpoint -force ${outputBaseName}_OOC_Kernel_Synth


#  ---------------------------------------------------------------------------------------------------


cd ../..

# Open the TOP Module 
open_checkpoint ./TOP_SYNTH/MOD_TOP.dcp

# insert the kernel design with the wrapper into TOP design
read_checkpoint -cell inst_PR_WRP_0 ./PR_WRP/OOC/${outputBaseName}_OOC_Kernel_Synth.dcp


create_pblock pblock_PR_Kernel
# generate pblock coordinates from automatic bounding box tool
source ./Scripts/Bound_v03.tcl
add_cells_to_pblock pblock_PR_Kernel [get_cells [list inst_PR_WRP_0]]

# create an internal pblock in order to prevent signal leaking
# number of rows to shrink (upper and bottom)
set row_shrink 5
# get coordinates from original pblock
set prop [get_property GRID_RANGES [get_pblocks pblock_PR_Kernel ]]
if [regexp  "(SLICE_X.*)+(:)+(SLICE_X.*)" $prop match slice1 colon slice2] {
puts $slice1
puts $slice2
}
set coord1 [regexp -all -inline -- {[0-9]+} $slice1]
set coord2 [regexp -all -inline -- {[0-9]+} $slice2]

# creates new coordinates shrinked
set new_pbl "SLICE_X[lindex $coord1 0]Y[expr {[lindex $coord1 1] + $row_shrink}]:SLICE_X[lindex $coord2 0]Y[expr {[lindex $coord2 1] - $row_shrink}]"

# creates new shrinked pblock
create_pblock pblock_PR_Kernel_int
resize_pblock pblock_PR_Kernel_int -add "$new_pbl"
set_property  gridtypes {RAMB36 RAMB18 DSP48E2 SLICE} [get_pblocks pblock_PR_Kernel_int]
add_cells_to_pblock pblock_PR_Kernel_int [get_cells [list inst_PR_WRP_0]]



write_checkpoint -force 1_post_constraints.dcp


opt_design

write_checkpoint    -force 2_post_opt.dcp


# place connection macros on SLOT
source ./Scripts/place_pre_3.tcl

place_design

write_checkpoint    -force 3_post_place.dcp

# route connection macros on SLOT
source ./Scripts/route_pre_3.tcl

write_checkpoint    -force 4_post_macro_route.dcp


# creates tunnel script for GoAhead
source ./Scripts/Gen_Macro_Tunnel.tcl

# generate blocker 
exec GoAhead -exec  ./Scripts/Gen_Blocker_v01.goa

# changes blocker to use VCC wires
exec ./Scripts/vcc.bat 

# place blocker
source ./Scripts/module_blocker_VCC.tcl

# fix the blocker
startgroup
set_property is_route_fixed 1 [get_nets {blocker_net_BlockSelection }]
set_property is_bel_fixed 1 [get_cells {VCC_for_BlockSelection }]
set_property is_loc_fixed 1 [get_cells {VCC_for_BlockSelection }]
endgroup

# route with fixed blocker
route_design
write_checkpoint  -force 5_route_after_fixing_blocker.dcp


# fix GND after routing
set gnd_nets [get_nets -hierarchical -filter {TYPE=="GROUND"}]
set_property is_route_fixed 1 [get_nets [lindex $gnd_nets 0]]

write_checkpoint  -force 6_blocker_plus_GND.dcp


# unfix the blocker
set_property is_route_fixed 0 [get_nets {blocker_net_BlockSelection }]
set_property is_bel_fixed 0 [get_cells {VCC_for_BlockSelection }]
set_property is_loc_fixed 1 [get_cells {VCC_for_BlockSelection }]

# remove the blocker
route_design    -unroute -physical_nets
route_design  -physical_nets


write_checkpoint  -force 7_route_final.dcp






